
 <!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="UTF-8">
  
    <title>Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="John Doe">
    
    <meta name="description" content="Usenix Security 2020 的一篇关于内核OOB漏洞自动化利用的文章，感觉写的不错。

@[toc]
简介这篇文章的主要目的是为了评估堆溢出漏洞的可利用性，从而方便开发人员判断漏洞修补的价值。文章提出了KOOBE，一个基于漏洞能力来实现内核堆溢出漏洞的自动化利用的工具。KOOBE的实现">
    
    
    
    
    
    <link rel="icon" href="/iskindar.github.io/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/iskindar.github.io/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/iskindar.github.io/img/pacman.jpg">
    
    
<link rel="stylesheet" href="/iskindar.github.io/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/iskindar.github.io/"><img src="/iskindar.github.io/img/logo.svg" alt="Hexo" title="Hexo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/iskindar.github.io/" title="Hexo">Hexo</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:example.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/iskindar.github.io/2020/11/05/论文阅读：KOOBE_ Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vulnerabilities/" title="" itemprop="url"></a>
  </h1>
  <p class="article-author">By
    
      <a href="http://example.com" title="John Doe">John Doe</a>
    </p>
  <p class="article-time">
    <time datetime="2020-11-05T11:30:13.744Z" itemprop="datePublished">2020-11-05</time>
    Updated:<time datetime="2020-11-05T11:27:26.273Z" itemprop="dateModified">2020-11-05</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A0%94%E7%A9%B6%E8%83%8C%E6%99%AF"><span class="toc-number">2.</span> <span class="toc-text">研究背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">研究方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%94%E7%A9%B6%E5%81%87%E8%AE%BE"><span class="toc-number">3.0.1.</span> <span class="toc-text">研究假设</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">3.0.2.</span> <span class="toc-text">核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.0.3.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0"><span class="toc-number">4.</span> <span class="toc-text">测试评估</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol>
		</div>
		
		<blockquote>
<p>Usenix Security 2020 的一篇关于内核OOB漏洞自动化利用的文章，感觉写的不错。</p>
</blockquote>
<p>@[toc]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这篇文章的主要目的是为了评估堆溢出漏洞的可利用性，从而方便开发人员判断漏洞修补的价值。文章提出了KOOBE，一个基于漏洞能力来实现内核堆溢出漏洞的自动化利用的工具。KOOBE的实现主要基于符号执行和基于能力的模糊测试这两种技术。实验在17个内核堆溢出漏洞（公共的exploit只有5个）中生成了11种利用策略。最后，作者认为其他的漏洞利用过程也有机会可以自动化。</p>
<h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>微软2019年的一篇报告指出在2006-2018年大约70%的漏洞都是内存安全漏洞。因此研究人员需要夜以继日的修补漏洞，这个过程还需要区分漏洞是否可以利用，从而优先修补重要的漏洞。对于难以利用的漏洞，研究人员通常会选择延缓修补的节奏。而内核漏洞的验证是很困难的工作，主要在于这两点：</p>
<ul>
<li><p>任何内核利用都是精心设计的多体的交互过程，涉及到一系列攻击者选择的输入（比如系统调用和其参数），而这些都是相互依赖的。</p>
</li>
<li><p>OS内核的内部状态数很多，很难穷尽搜索空间去寻找可利用的状态。</p>
</li>
</ul>
<p>因此，自动化评估内核漏洞是否修复就成了一个很重要的问题。这篇文章的目的就是要自动化评估内核漏洞的可利用性，进而帮助研究人员判断漏洞的重要性。</p>
<h2 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h2><h4 id="研究假设"><a href="#研究假设" class="headerlink" title="研究假设"></a>研究假设</h4><p>给定一个PoC触发一个或多个OOB访问，系统生成1个或多个利用原语来实现指令指针的劫持（Instruction Pointer Hijacking）。也就是说，没有到任意代码执行这步，所以也就不是端到端的漏洞自动化利用。但是有互补的技术来补充，比如KEPLER可以自动化将指令指针劫持转换为任意代码执行。</p>
<p>另外，文章假设的内核的防御机制有以下三个，但实际上真正需要绕过的机制只有SMAP，因为作者只做到指令指针的劫持部分：</p>
<ul>
<li>KASLR（Kernel Address Space Layout Randomization）</li>
<li>SMEP（Supervisor Mode Execution Prevention）</li>
<li>SMAP（Supervisor Mode Access Prevention）</li>
</ul>
<h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>在背景部分，作者给出了内核堆溢出的利用过程图解。首先分析漏洞的能力，了解漏洞能覆盖写多少字节，能写多远，以及能写的值。接着，利用heap feng shui技术构造堆的布局，消耗cache当其重填一个新的页的时候，后续的分配就会返回一个连续的地址。以便让分配的漏洞对象和目标对象挨在一起。然后，选择一个目标对象。让其分配到一起。最后，调整PoC用理想值覆盖重要数据，实现指令指针的劫持。</p>
<p>基于以上的漏洞利用过程，KOOBE的设计分为五个部分：</p>
<ul>
<li>漏洞分析：试图发现所有的漏洞点，并标识对应的漏洞对象</li>
<li>能力归纳：根据PoC来为OOB漏洞生成一个能力</li>
<li>能力探索：探索这个漏洞其他潜在的能力</li>
<li>可利用性评估：选择一个合适的目标对象，产生一个方案（具体的系统调用）</li>
<li>利用原语综合：根据上面的系统调用，结合Heap Feng Shui技术来产生exp</li>
</ul>
<p>漏洞分析这个部分的工作有点像KASAN，但是KASAN不能提供完整的漏洞点及准确的与漏洞点对应的漏洞对象。作者在这个工作的基础上增加了符号追踪技术。具体点就是在每个对象创建的时候，为其分配一个唯一的符号值，然后用符号追踪技术追踪每个对象。所以对于每次内存访问，如果其包含一个符号表达式，我们就可以直接提取想要的对象。而且，通过查询指针的符号表达式的可能范围，可以发现给的PoC没有触发的潜在溢出。</p>
<p>能力归纳这部分，作者对漏洞能力给出了具体的定义，简单来说，一条PoC路径的能力包括漏洞对象的大小，执行p路径的条件限制集合，以及OOB写漏洞的三个特征。OOB写漏洞的三个特征，可概括为如下三点：</p>
<ul>
<li>写的距离有多远（how far the write can reach）</li>
<li>能写多少字节（how many bytes can be written）</li>
<li>可以写什么值（what value can be written）</li>
</ul>
<p>另外，作者还定义了两个PoC能力的比较，也为后面的能力导向的模糊测试的实现奠定了理论基础。</p>
<p>能力探索，存在的意义是给定的PoC通常只有一条路径，会限制我们发现漏洞完整的能力。因此，需要去探索新的PoC，来发掘漏洞完整的能力。能力探索的流程可以分为三步：</p>
<ul>
<li><p>去搜寻新的PoC，来扩展现有的能力或者发现一个新的能力</p>
</li>
<li><p>接着重复能力归纳和可利用性评估步骤</p>
</li>
<li><p>直到成功或者时间超过了我们预设的值</p>
</li>
</ul>
<p>具体的实现方法，作者提出了能力导向的模糊测试，也是我认为本文的亮点所在。实际上就是将现有的覆盖率导向的模糊测试修改为能力导向的模糊测试。原本覆盖率导向的模糊测试，是基于覆盖率这一指标，来决定生成测试样例。这里就是基于发现的新能力是否大于旧能力来决定如何生成测试样例。覆盖率导向的模糊测试可以增加发现crash路径的概率，能力导向的模糊测试偏重于发现新的PoC的概率。</p>
<p>到可利用性评估这部分，系统会试图搜索一个或多个合适的目标对象。整个过程实际上就是根据目标对象的条件约束来与能力进行匹配。比如，一个合法的指针的约束就是，其必须指向一个合法的用户空间或者内核空间。然后，KOOBE将目标约束堆叠在前面获得的功能之上，并将它们提供给求解程序以获得解决方案。如果没有产生结果，那就去匹配下一个。在这个步骤，还提到了能力合成的概念。当一个能力单独使用时，不一定能够满足给定目标对象的要求。这不意味着这个能力没有用了，还有可能我们重复使用这个能力，来多次触发OOB写，来达到我们的目的。另外有时候有些利用需要结合多种不同能力来实现，文章用了一个贪心算法来实现能力的合成。</p>
<p>最后利用原语综合这部分，就是用Heap Feng Shui技术来构造内存布局。同时，使用physmap 喷射技术来绕过内核的SMAP防御机制。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>KOOBE主要是基于三个现有的工作来实现的：</p>
<ul>
<li>Syzkaller（内核的模糊测试工具）</li>
<li>S2E（符号执行框架）</li>
<li>Angr（二进制分析引擎）</li>
</ul>
<p>在实现过程中，作者提到了几个实现上的挑战：</p>
<ul>
<li>内核crash需要重启</li>
<li>符号执行引擎对符号化长度的支持很差</li>
<li>符号执行不好处理循环</li>
<li>符号索引和循环边界导致的路径冲突问题</li>
<li>目标对象收集问题</li>
</ul>
<p>内核产生crash需要重启，这样每次模糊测试产生crash就重启一下的话，会有很大的时间开销，作者采取的方式是，在内核中插桩，来跳过导致OOB访问的指令，但同时有新的指令，会保存下来，但也导致了系统状态的不一致性，也就是存在假阳性的情况。</p>
<p>对于符号执行引擎对符号化长度的支持很差这个问题，作者实际上采用了一种相对高效的枚举方法，用最小的OOB长度去试，从而避免破坏系统数据。</p>
<p>对于符号执行处理循环上，作者借鉴了SAGE的思路，利用循环守卫模式匹配规则来自动推断index。不过不是使用原始论文中的动态分析方法，而是用angr来静态分析。</p>
<p>至于符号索引和循环边界导致的路径冲突问题，作者去除了不相关的条件限制，比如printk()函数引起的。</p>
<p>在目标对象收集问题上，作者用LLVM pass构建内核的调用图来处理。同时，作者也补充说明，也可以使用SLAKE这篇文章的来解决。</p>
<h2 id="测试评估"><a href="#测试评估" class="headerlink" title="测试评估"></a>测试评估</h2><p>评估使用的漏洞是从CVE数据库和syzbot平台上获取的，分别从这两个平台取7和10个内核堆溢出漏洞。关于syzbot漏洞的选择，作者做了一个说明。平台上有28个堆溢出漏洞，其中8个是不提供c代码测试，8个是由同一个漏洞引起，1个需要错误注入来触发，1个需要root权限来触发，1个已经和CVE关联了。所以，只选择这个平台的10个漏洞。</p>
<p>最后的结果是，7个CVE漏洞中的公开利用策略有4个，产生了11个利用策略，潜在的策略有503个。10个syzbot中的漏洞的公开利用策略有1个，产生了8个利用策略，但其中有一半的漏洞仍然没有产生利用策略。作者对这些没有exp的策略进行验证，发现以他们的知识水平，确实是没有利用策略。</p>
<p>另外，作者验证了去除条件限制的优化方法，发现这种优化确实减少了使用时的时间开销。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章和FUZE那篇文章很像。不过那篇是提出内核UAF漏洞的自动化利用。这篇是针对内核堆溢出漏洞的自动化利用。这篇文章的亮点在于漏洞能力的提出，并且对堆溢出漏洞能力做了定义，因此衍生出了基于能力导向的模糊测试。虽然这篇文章没有实现端到端的漏洞自动化利用，但是有很多补充的技术，比如KEPLER，可以将指令指针的劫持自动转化为任意代码执行。二者相结合就可以实现完整的内核漏洞自动化利用。</p>
<p>文章使用了Heap Feng Shui策略，实际上简化了很多情况。如果遇到系统有细粒度的随机化机制（Diehard），Heap Feng Shui可能就不好用了，这也意味着这个自动化工具在应用上的一些局限性。</p>
<p>KOOBE中的Fuzzing在种子选择策略上还可再做优化。文中的种子选择策略，只是随机在能力和覆盖率这两个指标挑选，作为模糊测试的导向。下一步的研究也许可以针对这里再作优化，比如在什么情况下，选择以覆盖率导向的模糊测试更优，在另外一种情况下，选择能力导向的模糊测试更优。</p>
<p>这篇文章对我也产生了一些启发。文中提到了对漏洞能力的定义，那么这个能力能不能作为一些机器学习应用在漏洞检测的一个特征呢？另外，文章的结果里列出了很多潜在的利用策略。如何自动化验证这些潜在的利用策略，应该也是一个很有意义的工作。这篇文章是起源于FUZE（内核的UAF漏洞利用），那么还有什么其他漏洞可以自动化利用？</p>
<p>除了idea给的启发，文章的写作风格看得也比较舒服，第三章的漏洞实例贯穿了全文，看文章的时候，结合例子，感觉理解得更深了。或许这种写作技巧可以借鉴到今后的学术写作上。</p>
  
	</div>
		<footer class="article-footer clearfix">




<div class="article-share" id="share">

  <div data-url="http://example.com/2020/11/05/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AKOOBE_%20Towards%20Facilitating%20Exploit%20Generation%20of%20Kernel%20Out-Of-Bounds%20Write%20Vulnerabilities/" data-title="Hexo" data-tsina="" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/iskindar.github.io/2020/11/05/【论文分享】Unleashing Use-Before-Initialization Vulnerabilities in the Linux Kernel Using Targeted Stack/" title="">
  <strong>PREVIOUS:</strong><br/>
  <span>
  (no title)</span>
</a>
</div>


<div class="next">
<a href="/iskindar.github.io/2020/11/05/论文阅读：SKEE_ A Lightweight Secure Kernel-level Execution Environment for ARM/"  title="">
 <strong>NEXT:</strong><br/> 
 <span>(no title)
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A0%94%E7%A9%B6%E8%83%8C%E6%99%AF"><span class="toc-number">2.</span> <span class="toc-text">研究背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">研究方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%94%E7%A9%B6%E5%81%87%E8%AE%BE"><span class="toc-number">3.0.1.</span> <span class="toc-text">研究假设</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">3.0.2.</span> <span class="toc-text">核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.0.3.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0"><span class="toc-number">4.</span> <span class="toc-text">测试评估</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  

  <div class="rsspart">
	<a href="" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2020 
		
		<a href="http://example.com" target="_blank" title="John Doe">John Doe</a>
		
		</p>
</div>
</footer>
    <script src="/iskindar.github.io/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
